
ğŸš¦ Par oÃ¹ commencer pour le projet Minishell

---

ğŸ”¹ Ã‰tape 1 : Mise en place de lâ€™environnement

- CrÃ©er un Makefile conforme avec les rÃ¨gles `all`, `clean`, `fclean`, `re`, `$(NAME)`.
- Configurer une structure de dossier claire : `src/`, `includes/`, `libft/`, `tests/`, etc.
- Importer `readline` et afficher un prompt simple.
- Afficher un message dâ€™accueil type "Minishell$ " et capturer lâ€™entrÃ©e utilisateur.

---

ğŸ”¹ Ã‰tape 2 : Gestion des signaux et contrÃ´le du terminal

- GÃ©rer `ctrl-C` (SIGINT), `ctrl-D` (EOF) et `ctrl-\` (SIGQUIT).
- Utiliser `signal()` ou `sigaction()` pour capturer les signaux.
- Assurer que `ctrl-C` nâ€™interrompt pas le programme, mais affiche un nouveau prompt.
- GÃ©rer proprement la fermeture du shell avec `ctrl-D`.

---

ğŸ”¹ Ã‰tape 3 : ImplÃ©menter les built-ins de base

- Commencer par les commandes simples sans redirection ni pipe :
  - `echo`, `pwd`, `cd`, `exit`
- Ces commandes doivent fonctionner **sans `fork()`** dans un premier temps.

---

ğŸ”¹ Ã‰tape 4 : Parsing simple

- Lire la commande en ligne.
- DÃ©couper par espace (sans encore gÃ©rer les quotes ni redirections).
- SÃ©parer les commandes par `|` si besoin, mais sans exÃ©cution encore.
- Stocker dans une structure de type "commande + arguments".

---

ğŸ”¹ Ã‰tape 5 : ExÃ©cution simple

- Si la commande nâ€™est pas un built-in, utiliser :
  - `fork()`, `execve()` et `waitpid()`
- Chercher l'exÃ©cutable dans le `PATH`.
- GÃ©rer les erreurs d'exÃ©cution : commande introuvable, mauvais arguments, etc.

---

ğŸ”¹ Ã‰tape 6 : Gestion de lâ€™environnement

- Copier lâ€™environnement de lâ€™utilisateur (`char **envp`) dans une structure propre.
- ImplÃ©menter `env`, `export`, `unset`, et gÃ©rer `$VAR`.
- ImplÃ©menter lâ€™expansion des variables dans les commandes (`$HOME`, `$?`, etc).

---

ğŸ”¹ Ã‰tape 7 : Redirections

- ImplÃ©menter les redirections `<`, `>`, `>>`.
- Utiliser `dup2()` pour rediriger `stdin` / `stdout`.
- Ne pas oublier de fermer les fichiers aprÃ¨s usage.

---

ğŸ”¹ Ã‰tape 8 : Pipes

- Permettre l'exÃ©cution de `cmd1 | cmd2 | cmd3`.
- CrÃ©er une `pipe()` par lien entre deux commandes.
- Dupliquer les bons `fd` avec `dup2()` avant `execve()`.

---

ğŸ”¹ Ã‰tape 9 : Quotes & Parsing avancÃ©

- GÃ©rer les quotes `'` et `"` :
  - `'abc $USER'` â†’ tout est littÃ©ral
  - `"abc $USER"` â†’ `$USER` est interprÃ©tÃ©
- Ne pas interprÃ©ter les mÃ©tacaractÃ¨res dans les quotes.

---

ğŸ”¹ Ã‰tape 10 : Heredoc

- ImplÃ©menter `<< DELIM`.
- Lire l'entrÃ©e utilisateur jusquâ€™Ã  trouver la ligne `DELIM`.
- Rediriger l'entrÃ©e vers un `pipe` temporaire ou un fichier temporaire.

---

ğŸ”¹ Ã‰tape 11 : Nettoyage et tests

- Nettoyer tous les `malloc`, `open`, etc.
- Utiliser `valgrind` systÃ©matiquement.
- CrÃ©er des fichiers de test automatisÃ©s pour valider les comportements.

---

ğŸ”¹ Ã‰tape 12 : Bonus (facultatif)

- ImplÃ©menter `&&`, `||`, prioritÃ©s avec parenthÃ¨ses.
- GÃ©rer les jokers `*` (wildcards).

